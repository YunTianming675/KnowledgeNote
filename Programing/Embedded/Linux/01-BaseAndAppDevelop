# 01. 挂载 NFS 文件系统

​	NFS（网络文件系统）是一种非常便捷的在服务器和客户端通过网络共享文件的方式。对于嵌入式 Linux 开发来说，可以直接在开发板上执行主机上的程序，访问主机上的文件，便于开发。

## 01.1 主机端配置

- 以 Ubuntu18.04 为例，Ubuntu18.04 默认没有安装 NFS 服务，使用如下命令安装：

```bash
sudo apt install nfs-kernel-server
```

- 之后在会新增一个 `/etc/exports` 文件，NFS 服务根据它的配置来运行。在最后一行添加如下内容：

```
/home/dlans/Work 192.168.1.0/24(rw,sync,all_squash,anonuid=1000,anongid=1000,no_subtree_check)
```

​	其中具体的地址配置需要根据自己的环境进行配置。

​	一些配置如下：

- `/home/dlans/Work`: 要共享的主机目录。
- `192.168.1.0/24`: 配置谁可以访问，其中 `/24` 是掩码，表示 24 个 1，结合前面的 IP 地址表示所有 IP 为 `192.168.1.*` 的主机均可以访问该目录。这个配置如果写成主机名，如 `localhost` 则只有该主机可以访问目录。
- `anonuid=1000`: 将客户机上的用户映射成本地 ID=1000 的用户

- `anongid=1000`: 将客户机上的用户映射成属于指定的本地用户组 ID
- `no_subtree_check`: 不检查子目录权限

> 配置中的 anonuid 和 anongid 把客户机的用户映射成本地 uid=1000 及 gid=1000 的用户，那么在客户端上使用不同的用户访问 NFS 共享目录时，都会具有 uid=1000 及 gid=1000 的用户的权限。在客户端的 A 用户能读写的文件，其它用户如 B 也能读写。这不是一种安全的访问设置方式，不过在开发中非常方便。

- 更新 exports 配置

```bash
sudo exportfs -arv
```

- 查看 NFS 共享情况

```bash
showmount -e
```

## 01.2 客户端配置

- 安装 NFS 客户端

```
sudo apt install nfs-common
```

- 查看 NFS 服务器共享目录

```bash
showmount -e 192.168.1.12
```

> 在不同网络下，服务器地址可能不一样

- 挂载 NFS 文件系统

```bash
sudo mount -t nfs 192.168.1.12:/home/dlans/Work /mnt/Work
```

- 取消挂载

```
sudo umount /mnt/Work
```

# 02. 文件操作

## 02.1 C 标准库

​	标准库实际是对系统调用的再次封装。例如 Windows 系统打开文件操作的 API 为 `OpenFile`，Linux 为 `open`，C 标准库都把它们封装为 `fopen`。

- fopen

    - 打开一个文件

    原型：

    ```c
    #include <stdio.h>
    FILE *fopen(const char *pathname, const char *mode);
    ```

    参数：

    - pathname: 要打开或创建的文件名
    - mode: 文件的打开方式

    | mode | 含义                                                         |
    | ---- | ------------------------------------------------------------ |
    | "r"  | 只读，文件指针位于文件开头                                   |
    | "r+" | 读和写，文件指针位于文件开头                                 |
    | "w"  | 写，将原内容清除，文件指针位于文件开头，文件不存在则创报错   |
    | "w+" | 写，将原内容清除，文件指针位于文件开头，文件不存在则创建新文件 |
    | "a"  | 追加，文件指针位于文件末尾，文件不存在则创建新文件           |
    | "a+" | 读和追加，文件指针位于文件末尾，文件不存在则创建新文件       |

    - 返回值：不为 `NULL` 时表示正常

- fread

    原型：

    ```c
    #include <stdio.h>
    size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
    ```

    参数：

    - ptr: 读取到的内容将通过该指针保存
    - size: 每项的大小
    - nmemb: 读取多少项数据
    - stream: 文件流

    返回值：成功读取的项数

- fwrite

    原型：

    ```c
    #include <stdio.h>
    size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
    ```

    参数：

    - ptr: 要写入文件的内容
    - size: 每项的大小
    - nmemb: 写入多少项数据
    - stream: 文件流

    返回值：成功写入的项数

- fclose

    - 关闭指定的文件流，关闭时会把尚未写入到文件的内容都写出。

    原型：

    ```c
    #include <stdio.h>
    int fclose(FILE *stream);
    ```

    参数：

    - stream: 文件流

    返回值：0 = 成功，其它 = 失败

- fflush

    原型：

    ```c
    #include <stdio.h>
    int fflush(FILE *stream);
    ```

    参数：

    - stream: 文件流

- fseek

    - 设置文件指针的位置

    原型：

    ```c
    #include <stdio.h>
    int fseek(FILE *stream, long offset, int whence);
    ```

    参数：

    - stream: 文件流
    - offset: 偏移位置
    - whence: 定义 offset 的含义

    | whence   | 含义                      |
    | -------- | ------------------------- |
    | SEEK_SET | offset 是一个绝对位置     |
    | SEEK_END | offset 以文件尾为参考点   |
    | SEEK_CUR | offset 以当前位置为参考点 |

## 02.2 系统调用

​	系统调用是一组函数及指令，是 Linux 系统提供给用户的一种操作接口。

- open

    Linux 可以使用 open 函数来打开文件

    原型：

    ```c
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);
    ```

    参数：

    - pathname: 文件路径
    - flags: 文件的打开方式

    | flags    | 含义                         |
    | -------- | ---------------------------- |
    | O_RDONLY | 只读                         |
    | O_WRONLY | 只写                         |
    | O_RDWR   | 读写                         |
    | O_CREAT  | 创建                         |
    | O_APPEND | 追加，数据写到结尾           |
    | O_TRUNC  | 如果文件存在，则清除文件内容 |

    > O_RDONLY、O_WRONLY、O_RDWR 只能三选一

    - mode: 当 flag = O_CREAT 时，必须使用 mode 参数来设置文件与用户相关的权限。各个参数可以使用 `|` 来组合

    |            | mode    | 含义                                   |
    | ---------- | ------- | -------------------------------------- |
    | 当前用户   | S_IRUSR | 用户有读权限                           |
    |            | S_IWUSR | 用户有写权限                           |
    |            | S_IXUSR | 用户有执行权限                         |
    |            | S_IRWXU | 用户有读、写、执行权限                 |
    | 当前用户组 | S_IRGRP | 当前用户组的其他用户有读权限           |
    |            | S_IWGRP | 当前用户组的其他用户有写权限           |
    |            | S_IXGRP | 当前用户组的其他用户有执行权限         |
    |            | S_IRWXG | 当前用户组的其他用户有读、写、执行权限 |
    | 其它用户   | S_IROTH | 其它用户有读权限                       |
    |            | S_IWOTH | 其它用户有写权限                       |
    |            | S_IXOTH | 其它用户有执行权限                     |
    |            | S_IROTH | 其它用户有读、写、执行权限             |

    返回值：文件描述符

    - 与 C 标准库的对应关系

    | fopen 的参数 | open 的参数                 |
    | ------------ | --------------------------- |
    | r            | O_RDONLY                    |
    | w            | O_WRONLY\|O_CREAT\|O_TRUNC  |
    | a            | O_WRONLY\|O_CREAT\|O_APPEND |
    | r+           | O_RDWR                      |
    | w+           | O_RDWR\|O_CREAT\|O_TRUNC    |
    | a+           | O_RDWR\|O_CREAT\|O_APPEND   |

- read

    从文件中读取若干字节的数据，保存到缓冲区中，并返回实际读取到的字节数。

    原型：

    ```c
    #include <unistd.h>
    ssize_t read(int fd, void *buf, size_t count);
    ```

    参数：

    - fd: 文件描述符
    - buf: 指向数据缓冲区的指针
    - count: 读取多少个字节的数据

    返回值：读取到的字节数

- write

    往文件写入内容，返回实际写入的字节长度。

    原型：

    ```c
    #include <unistd.h>
    ssize_t write(int fd, const void *buf, size_t count);
    ```

    参数：

