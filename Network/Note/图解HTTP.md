# 01. Web 及网络基础

## 01.3 网络基础 TCP/IP

​	通常使用的网络是在 TCP/IP 协议族的基础上运作的，HTTP 属于它内部的一个子集。

### 01.3.1 TCP/IP 协议族

​	计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。这种规则就称之为协议。

### 01.3.2 TCP/IP 的分层管理

​	TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。

- 应用层

    决定向用户提供应用服务时的通信的活动。TCP/IP 协议族内预存各类通用的应用服务。如 FTP、DNS 和 HTTP 等。

- 传输层

    对应用层提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP 和 UDP。

- 网络层（网络互联层）

    处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定通过怎样的路径（传输路线）到达对方计算机，并把数据包发送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层的作用就是在众多的选项内选择一条传输路线。

- 链路层（数据链路层、网络接口层）

    处理网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC 及光纤等物理可见部分。

### 01.3.3 TCP/IP 通信传输流

在客户端：

| 应用层 | HTTP 客户端 |
| ------ | ----------- |
| 传输层 | TCP         |
| 网络层 | IP          |
| 链路层 | 网络        |

在服务端：

| 应用层 | HTTP 服务器 |
| ------ | ----------- |
| 传输层 | TCP         |
| 网络层 | IP          |
| 链路层 | 网络        |

## 01.4 与 HTTP 关系密切的协议：ip、tcp 和 dns

### 1.4.2 确保可靠的 TCP 的协议

​	TCP 协议位于传输层，提供可靠的字节流服务（Byte Stream Service）。TCP 协议为了更容易传输大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。

> 字节流服务：为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。

- TCP 的三次握手

    为了准确无误地将数据送达目标处，TCP 采用三次握手策略。发送端首先发送一个带 SYN 标志地数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志地数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志地数据包，代表握手结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同地顺序发送相同地数据包。

## 1.7 URI 和 URL

### 1.7.2 URI 格式

​	绝对 URI 的格式，以如下 URI 为例

```
http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1
```

- `http://`: 协议方案名。获取访问资源时要指定的协议类型，不区分大小写。
- `user:pass`: 登录信息。指定用户名和密码作为从服务器端获取资源时必要的登录信息。此项是**可选项**。
- `www.example.jp`: 服务器地址。使用绝对 URI 必须指定待访问的服务器地址。地址可以是域名、如 192.168.1.1 的 IPv4 地址和如 [0:0:0:0:0:0:0:1] 这样的 IPv6 地址。
- `80`: 服务器端口号。**可选项**，省略时使用默认端口。

- `/dir/index.htm`: 带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构类似。
- `uid=1`: 查询字符串。针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，**可选**。
- `ch1`: 片段标识符。标记已获取资源中的子资源，**可选**。

# 02. 简单的 HTTP 协议

## 2.2 通过请求和响应的交换达成通信

​	HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，**肯定是从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应**。

- 请求报文的构成：请求方法、请求 URI、协议版本、可选的请求首部字段、内容实体。

    ```
    # 方法 URI        协议版本
    POST /form/entry HTTP/1.1
    
    # 请求首部字段
    Host: hacker.jp
    Connection: keep-alive
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 16
    
    # 内容实体
    name=ueno&age=37
    ```

    

## 02.5 告知服务器意图的 HTTP 方法

### GET

​	获取资源，示例：

```
GET /index.html HTTP/1.1
Host: www.hacker.jp
```

​	响应：返回 `index.html` 的页面资源

### POST

​	传输实体主体，示例：

```
POST /submit.cgi HTTP/1.1
Host: www.hacker.jp
Content-Length: 1560
```

​	响应：返回 `submit.cgi` 接收数据的处理结果

### PUT

​	传输文件。要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但是，**PUT 方法本身不带验证机制，存在安全问题**，因此一般网站不使用该方法。

### HEAD

​	获得报文首部。同 GET，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期等。

### DELETE

​	删除文件。同样**不带验证机制**，存在安全问题。

### OPTIONS

​	询问支持的方法，查询针对请求 URI 指定的资源支持的方法。

### TRACE

​	追踪路径。让服务器端将之前的请求通信环回给客户端。发送请求时，在 `Max-Forwards` 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好为 0 时就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。

### CONNECT

​	要求用隧道协议连接代理。

## 02.7 持久连接节省通信量

### 02.7.1 持久连接

​	HTTP 的早期版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。这在小容量的文本传输中没有问题，但随着 HTTP 的普及，文档中包含大量图片的情况多了起来。为避免无谓的 TCP 连接建立和断开，增加通信量的开销，HTTP 提出了持久连接的方法。特点是，**只要任意一端没有明确提出断开连接，则保持 TCP 连接状态**。

### 02.7.2 管线化

​	持久连接使多数请求以管线化方式发送成为可能，从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术指不用等待响应也可以直接发送下一个请求。

## 02.8 使用 Cookie 的状态管理

​	HTTP 是无状态协议，**不对之前发生过的请求和响应的状态进行管理，意味着无法根据之前的状态进行本次的请求处理**。不保存状态节约了服务器的 CPU 及内存资源的消耗。

​	Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

# 03. HTTP 报文内的 HTTP 信息

## 03.1 HTTP 报文

​	HTTP 报文本身是由多行数据构成的字符串文本，并以 CR+LF 作换行符。CR：回车符，0x0D。LF：换行符：0x0A

```
报文首部
空行
报文主体
```

## 03.5 获取部分内容的范围请求

​	从下载中断处继续下载的机制。对一份 10000 字节大小的资源，使用范围请求，只请求 5001~10000 字节的资源。范围请求的首部字段为 `Range`。示例：

```
# 请求 5001~10000 字节
Range: bytes=5001-10000

# 5001 字节之后全部的
Range: butes=5001-

# 从一开始到 3000 字节和 5000~7000 多重范围
Range: bytes=-3000, 5000-7000
```

## 03.6 内容协商返回最合适的内容

​	当浏览器的默认语言为中文，访问相同 URI 的网页时，显示中文的页面；如果默认语言为英文，则显示英文版的页面。这样的机制称为内容协商。包含在**请求报文中**的某些首部字段就是判断的标准，例如：

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Lanuage

​	内容协商技术有以下三种类型：

1. 服务器驱动协商

    以请求的首部字段为参考，在服务器端自动处理。但对用户来说，**不一定能筛选出最优内容**。

2. 客户端驱动协商

    用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。

3. 透明协商

    服务器驱动和客户端驱动的结合。

# 04. 返回结果的 HTTP 状态码

## 04.1 状态码告知从服务器端返回的请求结果

​	状态码中的第一位指定了响应类别，后两位无分类。响应类别如下：

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

​	只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码或服务器自行创建状态码都每问题。

# 05. 与 HTTP 协作的 Web 服务器

## 05.1 单台主机实现多个域名

利用虚拟主机技术，即使只有一台物理主机，也可以实现多个主机，体现为一台主机管理了多个域名。那么在 DNS 解析后，将获得相同的实际物理主机 IP 地址，因此，在 Host 首部内必须完整指定主机名或域名的 URI 才能知道具体访问的是哪个域名。

> 即客户端发送的首部信息内必须包含首部字段 `Host`，即使主机没有设定主机名，也要发送一个空值，即字段信息为空白

## 05.2 通信数据转发程序：代理、网关、隧道

这些应用程序和服务器可以将请求转发给线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。

### 代理

代理是一种有转发功能的应用程序，它扮演位于服务器和客户端中间人的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息。该信息会标记出经过的主机信息。代理按两种基准进行分类，一种是是否使用缓存，另一种是是否会修改报文：

- 缓存代理

    代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

- 透明代理

    转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。

### 网关

网关是转发其它服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。

网关能使通信线路上的服务器提供非 HTTP 协议服务。利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保安全的连接。

### 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

隧道可按要求建立起一条与其它服务器的通信线路，届时能使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

隧道本身不会去解析 HTTP 请求。

# 06. HTTP 首部

HTTP 报文结构：

- 报文首部
- 空行（CR+LF）
- 报文主体

报文首部必须存在，客户端和服务器处理时起作用的信息几乎都在报文首部。

## 06.1 报文首部

- 请求行
- 请求首部字段
- 通用首部字段
- 实体首部字段
- 其它

## 06.2 首部字段

首部字段由字段名和字段值构成，例如 HTTP 首部中以 `Content-Type` 字段来表示报文主体的对象类型

```http
Content-Type: text/html
```

### 端到端首部和逐跳首部

- 端到端首部（End to end Header）

    在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发

- 逐跳首部（Hop by hop Header）

    在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发，如果要使用该首部，需要提供 `Connection` 首部字段。以下是逐跳首部，此外都是端到端首部

    - Connection
    - Keep-Alive
    - Proxy-Authenticate
    - Proxy-Authorization
    - Trailer
    - TE
    - Transfer-Encoding
    - Upgrade

# 07. 确保 Web 安全的 HTTPS

## 07.1 HTTP 缺点

- 通信使用明文，内容有可能会被窃听
- 不验证通信双方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

### 07.1.1 通信使用明文可能会被窃听

由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体进行加密，即 HTTP 报文使用明文发送。

- TCP/IP 是可能被窃听的网络

    所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遇到恶意窥视行为。即使已经加密过处理的信息，也会被窥视到通信内容，只是如果内容经过加密，就有可能让人无法破解报文信息的含义。

- 通信的加密

    用 SSL 建立安全通信线路后，就可以在这条线路上进行 HTTP 通信，与 SSL 组合使用的 HTTP 被称为 HTTPS

- 内容的加密

    对 HTTP 报文进行加密再发送，注意仅加密报文，首部未被加密，且**客户端和服务器端要具备相同的加密和解密机制**。同时，因为未对整个线路加密，所以**内容仍有被篡改的风险**

### 07.1.2 不验证通信双方的身份就可能遭遇伪装

HTTP 协议中，服务器不论是谁发送过来请求都会返回响应，因此存在下列隐患：

- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器，有可能是已伪装的 Web 服务器
- 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端，有可能是已伪装的客户端
- 无法确定正在通信的对方是否具备访问权限，因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限
- 无法判定请求来自何方、出自谁手
- 即使是无意义的请求也照单全收，无法阻止海量请求下的 DOS 攻击

## 07.2 HTTP + 加密 + 认证 + 完整性保护 = HTTPS

### 07.2.2 HTTPS 是身披 SSL 外壳的 HTTP

HTTPS 并非应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替。通常，HTTP 直接和 TCP 通信，当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信。

> SSL 是独立于 HTTP 的协议，所以不光是 HTTP，其它运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。

### 07.2.3 相互交换密钥的公开密钥加密技术

SSL 采用公开密钥加密的加密处理方式

- 加密和解密使用同一个密钥的方式称为共享密钥加密，也叫做对称密钥加密。对称加密的 Web 中的使用困境为必须将密钥发给对方，但密钥的转发有可能被窃听，且如果能安全地转发密钥，则数据也能安全送达

使用两把密钥的公开密钥加密

- 即非对称加密，公开密钥可以发送给任何人。发送方使用公开密钥加密，接收方使用私有密钥解密

HTTPS 采用混合加密形式

- 非堆成加密处理起来比对称加密复杂，因此在交换密钥阶段使用非对称加密，之后的建立通信阶段则使用对称加密的形式

### 07.2.4 证明公开密钥正确性的证书

非对称加密无法证明公开密钥本身就是真实的公开密钥，客户端收到的公开密钥可能已被篡改。证书认证及之后通信流程：

1. 服务器把自己的公开密钥登录至数字证书认证机构

2. 数字证书认证机构用自己的私有密钥向服务器的公开密钥签署数字签名并颁发公钥证书

3. 客户端拿到服务器的公钥证书后，使用数字认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性

    > 数字证书认证机构的公开密钥已事先植入到浏览器中

4. 使用服务器的公开密钥对报文加密后发送

5. 服务器用私钥对报文解密

用以确认客户端的客户端证书

- HTTPS 中还可以使用客户端证书，客户端证书可证明与服务器通信的是预料之内的客户端

客户端证书的现状

- 用户需要自行安装客户端证书且需付费，导致客户端仅用于特殊用途的业务，如网上银行，它会要求确认用户的客户端证书

客户端证书的问题

- 只能证明客户端存在，不能证明用户本人的真实有效性。只要获得了安装有客户端证书的计算机的使用权限，也就同时拥有了客户端证书的使用权限

由自认证机构颁发的证书称为自签名证书

- 使用 OpenSSL 开源程序，每个人都可以构建一套属于自己的认证机构，从而给自己的服务器颁发证书
- 独立构建的认证机构叫做自认证机构，由自认证机构办法的证书也被称为自签名证书。浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”

### 07.2.5 HTTPS 的安全通信机制

- HTTPS 通信步骤：

1. 客户端发送 `Client Hello` 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件列表
2. 服务器可进行 SSL 通信时，会以 `Server Hello` 报文作为应答。该报文中同样包含 SSL 版本和加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的
3. 服务器发送 `Certificate` 报文，报文中包含公开密钥证书
4. 服务器发送 `Server Hello Done` 报文通知客户端，最初的 SSL 握手协商部分结束
5. SSL 第一次握手结束后，客户端以 `Client Key Exchange` 报文作为回应。报文中包含通信加密中使用的一种被称为 `Pre-master secret` 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密
6. 客户端发送 `Change Cipher Spec` 报文。提示服务器，在此报文之后的通信会使用 `Pre-master secret` 密钥加密
7. 客户端发送 `Finished` 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准
8. 服务器同样发送 `Change Cipher Spec` 报文
9. 服务器发送 `Finished` 报文
10. 服务器和客户端的 `Finished` 报文交换完毕后，SSL 连接就算建立完成，从此开始进行应用层协议的通信，即发送 HTTP 请求
11. 应用层协议通信
12. 最后由客户端断开连接，断开连接时，发送 `close_notify` 报文

- SSL 速度慢吗

