# 01. Web 及网络基础

## 01.3 网络基础 TCP/IP

​	通常使用的网络是在 TCP/IP 协议族的基础上运作的，HTTP 属于它内部的一个子集。

### 01.3.1 TCP/IP 协议族

​	计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。这种规则就称之为协议。

### 01.3.2 TCP/IP 的分层管理

​	TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。

- 应用层

    决定向用户提供应用服务时的通信的活动。TCP/IP 协议族内预存各类通用的应用服务。如 FTP、DNS 和 HTTP 等。

- 传输层

    对应用层提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP 和 UDP。

- 网络层（网络互联层）

    处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定通过怎样的路径（传输路线）到达对方计算机，并把数据包发送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层的作用就是在众多的选项内选择一条传输路线。

- 链路层（数据链路层、网络接口层）

    处理网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC 及光纤等物理可见部分。

### 01.3.3 TCP/IP 通信传输流

在客户端：

| 应用层 | HTTP 客户端 |
| ------ | ----------- |
| 传输层 | TCP         |
| 网络层 | IP          |
| 链路层 | 网络        |

在服务端：

| 应用层 | HTTP 服务器 |
| ------ | ----------- |
| 传输层 | TCP         |
| 网络层 | IP          |
| 链路层 | 网络        |

## 01.4 与 HTTP 关系密切的协议：ip、tcp 和 dns

### 1.4.2 确保可靠的 TCP 的协议

​	TCP 协议位于传输层，提供可靠的字节流服务（Byte Stream Service）。TCP 协议为了更容易传输大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。

> 字节流服务：为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。

- TCP 的三次握手

    为了准确无误地将数据送达目标处，TCP 采用三次握手策略。发送端首先发送一个带 SYN 标志地数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志地数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志地数据包，代表握手结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同地顺序发送相同地数据包。

## 1.7 URI 和 URL

### 1.7.2 URI 格式

​	绝对 URI 的格式，以如下 URI 为例

```
http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1
```

- `http://`: 协议方案名。获取访问资源时要指定的协议类型，不区分大小写。
- `user:pass`: 登录信息。指定用户名和密码作为从服务器端获取资源时必要的登录信息。此项是**可选项**。
- `www.example.jp`: 服务器地址。使用绝对 URI 必须指定待访问的服务器地址。地址可以是域名、如 192.168.1.1 的 IPv4 地址和如 [0:0:0:0:0:0:0:1] 这样的 IPv6 地址。
- `80`: 服务器端口号。**可选项**，省略时使用默认端口。

- `/dir/index.htm`: 带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构类似。
- `uid=1`: 查询字符串。针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，**可选**。
- `ch1`: 片段标识符。标记已获取资源中的子资源，**可选**。

# 02. 简单的 HTTP 协议

## 2.2 通过请求和响应的交换达成通信

​	HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，**肯定是从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应**。

- 请求报文的构成：请求方法、请求 URI、协议版本、可选的请求首部字段、内容实体。

    ```
    # 方法 URI        协议版本
    POST /form/entry HTTP/1.1
    
    # 请求首部字段
    Host: hacker.jp
    Connection: keep-alive
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 16
    
    # 内容实体
    name=ueno&age=37
    ```

    

## 02.5 告知服务器意图的 HTTP 方法

### GET

​	获取资源，示例：

```
GET /index.html HTTP/1.1
Host: www.hacker.jp
```

​	响应：返回 `index.html` 的页面资源

### POST

​	传输实体主体，示例：

```
POST /submit.cgi HTTP/1.1
Host: www.hacker.jp
Content-Length: 1560
```

​	响应：返回 `submit.cgi` 接收数据的处理结果

### PUT

​	传输文件。要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但是，**PUT 方法本身不带验证机制，存在安全问题**，因此一般网站不使用该方法。

### HEAD

​	获得报文首部。同 GET，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期等。

### DELETE

​	删除文件。同样**不带验证机制**，存在安全问题。

### OPTIONS

​	询问支持的方法，查询针对请求 URI 指定的资源支持的方法。

### TRACE

​	追踪路径。让服务器端将之前的请求通信环回给客户端。发送请求时，在 `Max-Forwards` 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好为 0 时就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。

### CONNECT

​	要求用隧道协议连接代理。

## 02.7 持久连接节省通信量

### 02.7.1 持久连接

​	HTTP 的早期版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。这在小容量的文本传输中没有问题，但随着 HTTP 的普及，文档中包含大量图片的情况多了起来。为避免无谓的 TCP 连接建立和断开，增加通信量的开销，HTTP 提出了持久连接的方法。特点是，**只要任意一端没有明确提出断开连接，则保持 TCP 连接状态**。

### 02.7.2 管线化

​	持久连接使多数请求以管线化方式发送成为可能，从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术指不用等待响应也可以直接发送下一个请求。

## 02.8 使用 Cookie 的状态管理

​	HTTP 是无状态协议，**不对之前发生过的请求和响应的状态进行管理，意味着无法根据之前的状态进行本次的请求处理**。不保存状态节约了服务器的 CPU 及内存资源的消耗。

​	Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

# 03. HTTP 报文内的 HTTP 信息

## 03.1 HTTP 报文

​	HTTP 报文本身是由多行数据构成的字符串文本，并以 CR+LF 作换行符。CR：回车符，0x0D。LF：换行符：0x0A

```
报文首部
空行
报文主体
```

## 03.5 获取部分内容的范围请求

​	从下载中断处继续下载的机制。对一份 10000 字节大小的资源，使用范围请求，只请求 5001~10000 字节的资源。范围请求的首部字段为 `Range`。示例：

```
# 请求 5001~10000 字节
Range: bytes=5001-10000

# 5001 字节之后全部的
Range: butes=5001-

# 从一开始到 3000 字节和 5000~7000 多重范围
Range: bytes=-3000, 5000-7000
```

## 03.6 内容协商返回最合适的内容

​	当浏览器的默认语言为中文，访问相同 URI 的网页时，显示中文的页面；如果默认语言为英文，则显示英文版的页面。这样的机制称为内容协商。包含在**请求报文中**的某些首部字段就是判断的标准，例如：

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Lanuage

​	内容协商技术有以下三种类型：

1. 服务器驱动协商

    以请求的首部字段为参考，在服务器端自动处理。但对用户来说，**不一定能筛选出最优内容**。

2. 客户端驱动协商

    用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。

3. 透明协商

    服务器驱动和客户端驱动的结合。

# 04. 返回结果的 HTTP 状态码

## 04.1 状态码告知从服务器端返回的请求结果

​	状态码中的第一位指定了响应类别，后两位无分类。响应类别如下：

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

​	只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码或服务器自行创建状态码都每问题。
